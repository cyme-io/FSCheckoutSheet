//
//  FSCheckoutSheet.swift
//
//  Created by Helge HeÃŸ on 30.05.20.
//

#if os(macOS)
import Cocoa
import WebKit

/**
 * A view controller used to drive a sheet to perform a checkout on the
 * FastSpring store.
 * Allows preconfiguring a product (and its quantity) to checkout.
 *
 * Usage from within another NSViewController:
 *
 *     let vc = FastSpringCheckoutVC()
 *     vc.checkoutProduct("soy-for-community-slacks",
 *                        in: "zeezide.onfastspring.com") {
 *         licenseKeys in
 *
 *         for licenseKey in licenseKeys {
 *             print("User",   licenseKey.name,
 *                   "bought", licenseKey.sku,
 *                   "code:",  licenseKey.code)
 *         }
 *     }
 *     self.presentAsSheet(vc)
 *
 * Note: Currently this is only reporting CocoaFob licenses.
 */
public final class FastSpringCheckoutVC: NSViewController {
  // ToS and PP links do not work? (would navigate to other page?)
  
  /**
   * Represents a purchased license, that is:
   * - its SKU as specified in the FastSpring admin panel
   * - the license name and license code generated by FastSpring
   */
  public struct LicenseKey {
    /// The SKU of the license as specified in the FastSpring admin panel
    public let sku  : String
    /// The license name as determined by FastSpring during checkout
    public let name : String
    /// The generated CocoaFob code
    public let code : String
  }
  
  /**
   * Configure the view controller for the checkout of a given product.
   *
   * - Parameter productPath: The (internal) name of the product, e.g. "soy-for-community-slacks"
   * - Parameter quantity: The product quantity to preconfigure (defaults to 1)
   * - Parameter storeFront: The name of the storefront, e.g. "zeezide.onfastspring.com"
   * - Parameter yield:
   *     A closure called to be called when the sheet is closed,
   *     containing the licenses keys the customer bought.
   *     (empty if the customer cancelled).
   * - Returns: `self`, the view controller (discardable)
   */
  @discardableResult
  public func checkoutProduct(_ productPath: String, quantity: Int = 1,
                              in storeFront: String,
                              yield : @escaping
                                ( _ licenseKeys: [ LicenseKey ] ) -> Void)
              -> Self
  {
    assert(callback == nil, "callback already set!")
    callback = yield
    
    _ = view // make sure it is loaded!
    
    assert(webView != nil)
    webView?.loadFastSpringCheckout(for: storeFront, productPath: productPath,
                                    quantity: quantity)
    return self
  }
  
  
  private var webView : WKWebView?
  
  private func dismiss() {
    if let pvc = presentingViewController {
      pvc.dismiss(self)
    }
    else if isViewLoaded, let window = view.window {
      window.close()
    }
    webView  = nil
    callback = nil
  }
  
  public override func cancelOperation(_ sender: Any?) {
    guard isViewLoaded else { return }
    dismiss()
  }
  
  public override func viewWillAppear() {
    super.viewWillAppear()
    spinner.startAnimation(nil)
  }
  public override func viewDidDisappear() {
    super.viewDidDisappear()
    emit([])
  }
  
  private var callback : (( _ licenseKeys: [ LicenseKey ] ) -> Void)?
  
  private func emit(_ keys: [ LicenseKey ]) {
    guard let cb = callback else { return }
    callback = nil
    cb(keys)
  }
  
  private let spinner : NSProgressIndicator = {
    let spinner = NSProgressIndicator()
    spinner.translatesAutoresizingMaskIntoConstraints = false
    spinner.style = .spinning
    spinner.isDisplayedWhenStopped = false
    return spinner
  }()

  public override func loadView() {
    let config : WKWebViewConfiguration = {
      let prefs = WKPreferences()
      prefs.javaScriptCanOpenWindowsAutomatically = true
      prefs.javaScriptEnabled = true
      prefs.javaEnabled       = false
      prefs.plugInsEnabled    = false
      
      let controller = WKUserContentController()
      controller.addUserScript(
        WKUserScript(source           : FindLicenseJavaScript,
                     injectionTime    : .atDocumentStart,
                     forMainFrameOnly : true)
      )
      controller.add(self, name: "zz")
      
      let config = WKWebViewConfiguration()
      config.preferences = prefs
      config.allowsAirPlayForMediaPlayback  = false
      config.suppressesIncrementalRendering = true
          
      config.userContentController = controller
      return config
    }()
    
    let webView = WKWebView(frame: .zero, configuration: config)
    webView.translatesAutoresizingMaskIntoConstraints = true
    webView.autoresizingMask   = [.width, .height]
    webView.navigationDelegate = self
    
    let buttonStack = NSStackView(views: [
      NSButton(title  : NSLocalizedString("Dismiss", comment: "Dismiss Button Caption"),
               target : self, action: #selector(cancelOperation(_:)))
    ])
    buttonStack.orientation = .horizontal
    buttonStack.alignment   = .firstBaseline
    buttonStack.edgeInsets  =
      NSEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
    
    let sep = NSBox(frame: .zero)
    sep.boxType = .separator
    
    let pageStack = NSStackView(views: [ webView, sep, buttonStack ])
    pageStack.orientation = .vertical
    pageStack.alignment   = .width
    pageStack.spacing     = 0
    
    pageStack.addSubview(spinner)
    
    self.webView = webView
    self.view    = pageStack
    
    let hc = view.widthAnchor .constraint(equalToConstant: 1024)
    let wc = view.heightAnchor.constraint(equalToConstant: 768)
    
    NSLayoutConstraint.activate([
      wc, hc,
      view.widthAnchor .constraint(greaterThanOrEqualToConstant: 800),
      view.heightAnchor.constraint(greaterThanOrEqualToConstant: 400),
      sep .heightAnchor.constraint(equalToConstant: 1),
      
      spinner.centerXAnchor.constraint(equalTo: view.centerXAnchor),
      spinner.centerYAnchor.constraint(equalTo: view.centerYAnchor),
    ])
  }
  
  fileprivate func handleScriptResult(_ anyJSON: Any) {
    guard let licensesJSON = anyJSON as? [ [ String: Any ] ] else {
      print("FSCheckout: could not decode JSON:", anyJSON)
      return
    }
    guard !licensesJSON.isEmpty else { return }
    
    let licenses : [ LicenseKey ] = licensesJSON.compactMap { json in
      assert(json["licenseType"] as? String == "CocoaFob_license")
      assert(json["type"]        as? String == "license")
      
      if let type = json["type"] as? String {
        guard type == "license" else { return nil }
      }
      
      guard let name = json["licenseName"] as? String,
            let code = json["license"]     as? String,
            let sku  = json["sku"]         as? String else {
        print("FSCheckout: Could not decode license JSON:", anyJSON)
        return nil
      }
      return LicenseKey(sku: sku, name: name, code: code)
    }
    
    if !licenses.isEmpty {
      emit(licenses)
      dismiss()
    }
  }
}

extension FastSpringCheckoutVC: WKNavigationDelegate {
  
  public
  func webView(_ webView: WKWebView,
               didFailProvisionalNavigation navigation: WKNavigation!,
               withError error: Error)
  {
    // TODO: show error, and link to webstore
    print("FSCheckout: failed prov nav:", error, navigation as Any)
    spinner.stopAnimation(nil)
  }
  
  private func isBlank() -> Bool {
    guard let url = webView?.url else { return true }
    return url.absoluteString == "about:blank"
  }

  public func webView(_ webView: WKWebView, didFinish n: WKNavigation!) {
    if !isBlank() { spinner.stopAnimation(nil) }
  }

  public func webView(_ webView: WKWebView, didFail n: WKNavigation!,
                      withError error: Error)
  {
    // TODO: show error?
    print("FSCheckout: failed nav:", error,
          webView.url?.absoluteString ?? "")
    spinner.stopAnimation(nil)
  }
}

extension FastSpringCheckoutVC: WKScriptMessageHandler {
  
  public func userContentController(_ ucc: WKUserContentController,
                                    didReceive message: WKScriptMessage)
  {
    guard message.name == "zz" else { assert(message.name == "zz"); return }
    handleScriptResult(message.body)
  }
}

fileprivate extension WKWebView {

  /**
   * Load the FastSpring checkout page into the WKWebView.
   *
   * The product and the quantity is preconfigured for checkout.
   *
   * Note: Arguments are not escaped in any way.
   *
   * - Parameter storeFront: The name of the storefront, e.g. "zeezide.onfastspring.com"
   * - Parameter productPath: The (internal) name of the product, e.g. "soy-for-community-slacks"
   * - Parameter quantity: The product quantity to preconfigure (defaults to 1)
   */
  func loadFastSpringCheckout(for storeFront : String,
                              productPath    : String,
                              quantity       : Int = 1)
  {
    let page = CheckoutPageHTML(for: storeFront, productPath: productPath,
                                quantity: quantity)
    loadHTMLString(page, baseURL: nil) // no base URL to distinguish this
  }
}

#endif // macOS
